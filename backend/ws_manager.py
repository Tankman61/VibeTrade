"""
WebSocket Manager for frontend communication.
Manages connections to frontend clients and broadcasts events.
"""
import asyncio
import json
from typing import Set, Dict, Any
from fastapi import WebSocket
import logging

logger = logging.getLogger(__name__)


class WebSocketManager:
    """
    Manages WebSocket connections to frontend clients.
    Broadcasts risk scores, interrupt events, and alerts.
    """
    
    def __init__(self):
        self.active_connections: Set[WebSocket] = set()
        self._lock = asyncio.Lock()
    
    async def connect(self, websocket: WebSocket):
        """Accept and register a new WebSocket connection."""
        await websocket.accept()
        async with self._lock:
            self.active_connections.add(websocket)
        logger.info(f"âœ… New frontend client connected. Total: {len(self.active_connections)}")
    
    async def disconnect(self, websocket: WebSocket):
        """Remove a WebSocket connection."""
        async with self._lock:
            self.active_connections.discard(websocket)
        logger.info(f"âŒ Frontend client disconnected. Total: {len(self.active_connections)}")
    
    async def send_personal_message(self, message: Dict[str, Any], websocket: WebSocket):
        """Send a message to a specific client."""
        try:
            await websocket.send_json(message)
        except Exception as e:
            logger.error(f"Error sending personal message: {e}")
            await self.disconnect(websocket)
    
    async def broadcast(self, message: Dict[str, Any]):
        """
        Broadcast a message to all connected clients.
        
        Args:
            message: Dictionary with 'type' and 'payload' fields
        """
        if not self.active_connections:
            return
        
        # Create list of connections to avoid modification during iteration
        connections = list(self.active_connections)
        
        # Send to all clients concurrently
        tasks = []
        for connection in connections:
            tasks.append(self._send_with_error_handling(connection, message))
        
        await asyncio.gather(*tasks, return_exceptions=True)
    
    async def _send_with_error_handling(self, websocket: WebSocket, message: Dict[str, Any]):
        """Send message with automatic disconnection on error."""
        try:
            await websocket.send_json(message)
        except Exception as e:
            logger.error(f"Error broadcasting to client: {e}")
            await self.disconnect(websocket)
    
    async def broadcast_risk_score(self, score: float):
        """
        Broadcast a risk score update to all clients.
        
        Args:
            score: Normalized risk score between 0 and 100
        """
        message = {
            "type": "RISK_SCORE",
            "payload": {
                "score": round(score, 2)
            }
        }
        await self.broadcast(message)
        logger.debug(f"ðŸ“Š Broadcasted risk score: {score:.2f}")
    
    async def broadcast_interrupt(self, roast: str, audio_url: str, risk_score: float):
        """
        Broadcast an interrupt event to all clients.
        
        Args:
            roast: The roast message generated by AI
            audio_url: URL to the TTS audio file
            risk_score: Current risk score that triggered the interrupt
        """
        message = {
            "type": "INTERRUPT",
            "payload": {
                "roast": roast,
                "audio_url": audio_url,
                "risk_score": round(risk_score, 2)
            }
        }
        await self.broadcast(message)
        logger.info(f"ðŸš¨ Broadcasted interrupt event (risk: {risk_score:.2f})")
    
    async def broadcast_alert(self, alert_type: str, message_text: str):
        """
        Broadcast a general alert to all clients.
        
        Args:
            alert_type: Type of alert (e.g., 'warning', 'info', 'error')
            message_text: Alert message text
        """
        message = {
            "type": "ALERT",
            "payload": {
                "alert_type": alert_type,
                "message": message_text
            }
        }
        await self.broadcast(message)
        logger.info(f"âš ï¸  Broadcasted alert: {alert_type} - {message_text}")
    
    async def broadcast_data_update(self, source: str, data: Dict[str, Any]):
        """
        Broadcast raw data update from a specific source.
        
        Args:
            source: Data source name ('crypto', 'polymarket', 'reddit')
            data: Data payload from the source
        """
        message = {
            "type": "DATA_UPDATE",
            "payload": {
                "source": source,
                "data": data
            }
        }
        await self.broadcast(message)
    
    def get_connection_count(self) -> int:
        """Get the number of active connections."""
        return len(self.active_connections)


# Global singleton instance
ws_manager = WebSocketManager()

